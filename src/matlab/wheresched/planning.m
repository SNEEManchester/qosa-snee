function [s] = test()

%This array stores the sites of the sensor network.
%The operators may be placed these sites.
global sites;
sites= {__SITES__};


%Maps sites in the routing tree to available memory
%Note that the sink should be assigned Inf here, so that we can give a 
%initial feasible assignment to the solver.
global memoryAvailable;
memoryAvailable = hashtable;
__MEMORY_AVAIL__

%Maps sites in the routing tree to available energy
global energyAvailable;
energyAvailable = hashtable;
__ENERGY_AVAIL__

%The routing tree upon which nodes may be placed.
%I note that we could (maybe) pass the network connectivity graph rather
%than a routing tree.  This depends on whether the edges of graph can be
%weighted.
global rt;
rt = graph;
__RT__ %+1 adjustment

global parentSite;
parentSite = hashtable;
__PARENT_SITE__

global siteChildren;
siteChildren = hashtable;
__SITE_CHILDREN__

%Maps siteId to the transmission energy for that edge
global txEnergy;
txEnergy = hashtable;
__TX_ENERGY__

%List of operator instances
global operatorinstances;
operatorinstances = {__OPERATOR_INSTANCES__};

%Maps operator instances to operators (so we can determine if two op instances are of the same type)
global opInstOperator;
opInstOperator = hashtable;
__OPINST_OPERATOR__

%Maps operator instance to sensor network site (location-sensitive 
%operator instances only).
global locationConstraints;
locationConstraints = hashtable;
__LOCATION_CONSTRAINTS__

%Maps operator instance to output size
global outputSize;
outputSize = hashtable;
__OUTPUT_SIZE__

%Maps operator instance to cardinality
global card;
card = hashtable;
__CARDINALITY__

%Maps operator instance to memory cost
global memoryCost;
memoryCost = hashtable;
__MEMORY_COST__

%Maps operator instance to energy cost
global energyCost;
energyCost = hashtable;
__ENERGY_COST__

%maps operator instances to position in assignment array
global opInstanceIndex;
opInstanceIndex = hashtable;
__OP_INST_INDEX__

%Maps operator instance to parent operator instance
global parentOpInst;
parentOpInst = hashtable;
__PARENTS__

%Maps operator instance to children operator instance array
global opInstChildren;
opInstChildren = hashtable;
__CHILDREN__

%Maps operator instance to deepest confluence site
global opInstDeepestConfSite;
opInstDeepestConfSite = hashtable;
__DEEPEST_CONFLUENCE_SITES__

%The sites which each operator instance has been assigned to
global assignment;
assignment = {__ASSIGNMENT__};

%List of operators
global operators;
operators = {__OPERATORS__};

%Maps operator to tuples per message
global tuplesPerMessage;
tuplesPerMessage = hashtable;
__TUPLES_PER_MESSAGE__

%Number of data reducing operator instances
numDataReducingOpInst = __NUM_DATA_REDUCING_OP_INST__;

%invoke the solver
global min_f;
min_f = Inf;
global initVal;
initVal = Inf;

%The maximum number number of neighbours to generate
global numNeighbours;
numNeighbours = __NUM_NEIGHBOURS__;

%The energy to receive a packet
global rxEnergy;
rxEnergy = __PACKET_RX_ENERGY__;

%The optimization goal; this determines the objective function to be used.
global opt_goal;
opt_goal='__OPTIMIZATION_GOAL__';

%QoS-aware version only. This makes the solver generate a second, initial 
%point based on heuristics.  The point is generated by pushing all data 
%decreasing operator instances to the lowest confluence site.
%Note that this point is not guaranteed to be feasible.
global heuristic_init_point;
heuristic_init_point = '__HEURISTIC_INITIAL_POINT__';

format long;

global searchTreeFile;
searchTreeFile = sprintf('search-tree-nn%d.dot', numNeighbours);
[h,ErrMsg] = fopen(searchTreeFile,'wt');
error(ErrMsg);
tmpStr = sprintf('digraph "search-tree" {\nsize = "11,8.5";\nrankdir="TB";\n\n');
fwrite(h,tmpStr,'char');
fclose(h);

%cache used for generating simple, unique point ids
global DAFidPidMap;
DAFidPidMap = hashtable;

global pidDAFidMap;
pidDAFidMap = {};

disp('About to invoke the solver')
[BestF,BestI,RunStats,RunSet] = mads_batch;
disp('Solver terminated')

disp(' ')
disp('*** DAFs generated ***')
disp(' ')
for i=1:1:length(pidDAFidMap)
	disp(sprintf('Pid=%d,\tDAF id=%s',i,pidDAFidMap{i}));
end
disp(' ')
disp('*** BEST ASSIGNMENT FOUND ***')
disp(' ')
disp('*** Summary ***')
disp(sprintf('min_f=%g',min_f))
disp(sprintf('init_val=%g',initVal))
disp(sprintf('num DAFs considered=%d',count(DAFidPidMap)))
disp(sprintf('num operator instances=%g',length(operatorinstances)))
disp(sprintf('num sites=%g',length(sites)))
disp(sprintf('num data reducing op instances=%g',numDataReducingOpInst))
disp(' ')
disp('*** Assignment ***')
displayAssignment(BestF.p);

[h,ErrMsg] = fopen(searchTreeFile,'at');
error(ErrMsg);
tmpStr = sprintf('}\n');
fwrite(h,tmpStr,'char');
fclose(h);

%clean up
free(rt)
clear rt


